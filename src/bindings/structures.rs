/* automatically generated by rust-bindgen 0.60.1 */

pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type size_t = ::std::os::raw::c_ulonglong;
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize);
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
#[doc = "Gr2 file header"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SHeader {
    pub magic: [u32; 4usize],
    pub sizeWithSectors: u32,
    pub format: u32,
    pub extra: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_SHeader() {
    assert_eq!(
        ::std::mem::size_of::<SHeader>(),
        32usize,
        concat!("Size of: ", stringify!(SHeader))
    );
    assert_eq!(
        ::std::mem::align_of::<SHeader>(),
        4usize,
        concat!("Alignment of ", stringify!(SHeader))
    );
    fn test_field_magic() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SHeader),
                "::",
                stringify!(magic)
            )
        );
    }
    test_field_magic();
    fn test_field_sizeWithSectors() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sizeWithSectors) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SHeader),
                "::",
                stringify!(sizeWithSectors)
            )
        );
    }
    test_field_sizeWithSectors();
    fn test_field_format() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(SHeader),
                "::",
                stringify!(format)
            )
        );
    }
    test_field_format();
    fn test_field_extra() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SHeader>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extra) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(SHeader),
                "::",
                stringify!(extra)
            )
        );
    }
    test_field_extra();
}
#[doc = "Gr2 file header"]
pub type THeader = SHeader;
#[doc = "Reference of a place in the data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SReference {
    pub sector: u32,
    pub position: u32,
}
#[test]
fn bindgen_test_layout_SReference() {
    assert_eq!(
        ::std::mem::size_of::<SReference>(),
        8usize,
        concat!("Size of: ", stringify!(SReference))
    );
    assert_eq!(
        ::std::mem::align_of::<SReference>(),
        4usize,
        concat!("Alignment of ", stringify!(SReference))
    );
    fn test_field_sector() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SReference>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sector) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SReference),
                "::",
                stringify!(sector)
            )
        );
    }
    test_field_sector();
    fn test_field_position() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SReference>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).position) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SReference),
                "::",
                stringify!(position)
            )
        );
    }
    test_field_position();
}
#[doc = "Reference of a place in the data"]
pub type TReference = SReference;
#[doc = "Gr2 file information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SFileInfo {
    pub format: i32,
    pub totalSize: u32,
    pub crc32: u32,
    pub fileInfoSize: u32,
    pub sectorCount: u32,
    pub type_: TReference,
    pub root: TReference,
    pub tag: u32,
    pub extra: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_SFileInfo() {
    assert_eq!(
        ::std::mem::size_of::<SFileInfo>(),
        72usize,
        concat!("Size of: ", stringify!(SFileInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<SFileInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(SFileInfo))
    );
    fn test_field_format() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SFileInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SFileInfo),
                "::",
                stringify!(format)
            )
        );
    }
    test_field_format();
    fn test_field_totalSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SFileInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).totalSize) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SFileInfo),
                "::",
                stringify!(totalSize)
            )
        );
    }
    test_field_totalSize();
    fn test_field_crc32() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SFileInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).crc32) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SFileInfo),
                "::",
                stringify!(crc32)
            )
        );
    }
    test_field_crc32();
    fn test_field_fileInfoSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SFileInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fileInfoSize) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(SFileInfo),
                "::",
                stringify!(fileInfoSize)
            )
        );
    }
    test_field_fileInfoSize();
    fn test_field_sectorCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SFileInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sectorCount) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SFileInfo),
                "::",
                stringify!(sectorCount)
            )
        );
    }
    test_field_sectorCount();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SFileInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(SFileInfo),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_root() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SFileInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).root) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(SFileInfo),
                "::",
                stringify!(root)
            )
        );
    }
    test_field_root();
    fn test_field_tag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SFileInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(SFileInfo),
                "::",
                stringify!(tag)
            )
        );
    }
    test_field_tag();
    fn test_field_extra() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SFileInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extra) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(SFileInfo),
                "::",
                stringify!(extra)
            )
        );
    }
    test_field_extra();
}
#[doc = "Gr2 file information"]
pub type TFileInfo = SFileInfo;
#[doc = "The fixup contains informations about fixing the sector pointers"]
#[doc = "(It's a way to use pointer based structure inside the code without crashing, like"]
#[doc = "fixing the pointer of the ArtToolInfo node name or it's children pointer)"]
#[doc = ""]
#[doc = "The destination information contains where the data should point, while"]
#[doc = "the source sector would contain the pointer information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SFixUpData {
    pub srcOffset: u32,
    pub dstSector: u32,
    pub dstOffset: u32,
}
#[test]
fn bindgen_test_layout_SFixUpData() {
    assert_eq!(
        ::std::mem::size_of::<SFixUpData>(),
        12usize,
        concat!("Size of: ", stringify!(SFixUpData))
    );
    assert_eq!(
        ::std::mem::align_of::<SFixUpData>(),
        4usize,
        concat!("Alignment of ", stringify!(SFixUpData))
    );
    fn test_field_srcOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SFixUpData>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcOffset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SFixUpData),
                "::",
                stringify!(srcOffset)
            )
        );
    }
    test_field_srcOffset();
    fn test_field_dstSector() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SFixUpData>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstSector) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SFixUpData),
                "::",
                stringify!(dstSector)
            )
        );
    }
    test_field_dstSector();
    fn test_field_dstOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SFixUpData>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstOffset) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SFixUpData),
                "::",
                stringify!(dstOffset)
            )
        );
    }
    test_field_dstOffset();
}
#[doc = "The fixup contains informations about fixing the sector pointers"]
#[doc = "(It's a way to use pointer based structure inside the code without crashing, like"]
#[doc = "fixing the pointer of the ArtToolInfo node name or it's children pointer)"]
#[doc = ""]
#[doc = "The destination information contains where the data should point, while"]
#[doc = "the source sector would contain the pointer information"]
pub type TFixUpData = SFixUpData;
#[doc = "The marshalling data contains information on how to fix the sector data when"]
#[doc = "the file endianness mismatch the CPU endianness"]
#[doc = ""]
#[doc = "The bytes of the node information are swapped based to match the correct CPU"]
#[doc = "endianness"]
#[doc = ""]
#[doc = "The destination contains the node information to swap in order to retrive the"]
#[doc = "member informations"]
#[doc = ""]
#[doc = "The source sector contains the data value to swap"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMarshallData {
    pub count: u32,
    pub srcOffset: u32,
    pub dstSector: u32,
    pub dstOffset: u32,
}
#[test]
fn bindgen_test_layout_SMarshallData() {
    assert_eq!(
        ::std::mem::size_of::<SMarshallData>(),
        16usize,
        concat!("Size of: ", stringify!(SMarshallData))
    );
    assert_eq!(
        ::std::mem::align_of::<SMarshallData>(),
        4usize,
        concat!("Alignment of ", stringify!(SMarshallData))
    );
    fn test_field_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMarshallData>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMarshallData),
                "::",
                stringify!(count)
            )
        );
    }
    test_field_count();
    fn test_field_srcOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMarshallData>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).srcOffset) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMarshallData),
                "::",
                stringify!(srcOffset)
            )
        );
    }
    test_field_srcOffset();
    fn test_field_dstSector() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMarshallData>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstSector) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SMarshallData),
                "::",
                stringify!(dstSector)
            )
        );
    }
    test_field_dstSector();
    fn test_field_dstOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMarshallData>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dstOffset) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(SMarshallData),
                "::",
                stringify!(dstOffset)
            )
        );
    }
    test_field_dstOffset();
}
#[doc = "The marshalling data contains information on how to fix the sector data when"]
#[doc = "the file endianness mismatch the CPU endianness"]
#[doc = ""]
#[doc = "The bytes of the node information are swapped based to match the correct CPU"]
#[doc = "endianness"]
#[doc = ""]
#[doc = "The destination contains the node information to swap in order to retrive the"]
#[doc = "member informations"]
#[doc = ""]
#[doc = "The source sector contains the data value to swap"]
pub type TMarshallData = SMarshallData;
#[doc = "Information of a Gr2 sector"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SSector {
    pub compressType: u32,
    pub dataOffset: u32,
    pub compressedLen: u32,
    pub decompressLen: u32,
    pub alignment: u32,
    pub oodleStop0: u32,
    pub oodleStop1: u32,
    pub fixupOffset: u32,
    pub fixupSize: u32,
    pub marshallOffset: u32,
    pub marshallSize: u32,
}
#[test]
fn bindgen_test_layout_SSector() {
    assert_eq!(
        ::std::mem::size_of::<SSector>(),
        44usize,
        concat!("Size of: ", stringify!(SSector))
    );
    assert_eq!(
        ::std::mem::align_of::<SSector>(),
        4usize,
        concat!("Alignment of ", stringify!(SSector))
    );
    fn test_field_compressType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SSector>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compressType) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SSector),
                "::",
                stringify!(compressType)
            )
        );
    }
    test_field_compressType();
    fn test_field_dataOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SSector>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dataOffset) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SSector),
                "::",
                stringify!(dataOffset)
            )
        );
    }
    test_field_dataOffset();
    fn test_field_compressedLen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SSector>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compressedLen) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SSector),
                "::",
                stringify!(compressedLen)
            )
        );
    }
    test_field_compressedLen();
    fn test_field_decompressLen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SSector>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).decompressLen) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(SSector),
                "::",
                stringify!(decompressLen)
            )
        );
    }
    test_field_decompressLen();
    fn test_field_alignment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SSector>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).alignment) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SSector),
                "::",
                stringify!(alignment)
            )
        );
    }
    test_field_alignment();
    fn test_field_oodleStop0() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SSector>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).oodleStop0) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(SSector),
                "::",
                stringify!(oodleStop0)
            )
        );
    }
    test_field_oodleStop0();
    fn test_field_oodleStop1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SSector>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).oodleStop1) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(SSector),
                "::",
                stringify!(oodleStop1)
            )
        );
    }
    test_field_oodleStop1();
    fn test_field_fixupOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SSector>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fixupOffset) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(SSector),
                "::",
                stringify!(fixupOffset)
            )
        );
    }
    test_field_fixupOffset();
    fn test_field_fixupSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SSector>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fixupSize) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(SSector),
                "::",
                stringify!(fixupSize)
            )
        );
    }
    test_field_fixupSize();
    fn test_field_marshallOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SSector>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).marshallOffset) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(SSector),
                "::",
                stringify!(marshallOffset)
            )
        );
    }
    test_field_marshallOffset();
    fn test_field_marshallSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SSector>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).marshallSize) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(SSector),
                "::",
                stringify!(marshallSize)
            )
        );
    }
    test_field_marshallSize();
}
#[doc = "Information of a Gr2 sector"]
pub type TSector = SSector;
#[doc = "information of a Gr2 node"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SNodeTypeInfo {
    pub type_: u32,
    pub nameOffset: u64,
    pub childrenOffset: u64,
    pub arraySize: i32,
    pub extra: [u32; 3usize],
    pub extra4: u64,
}
#[test]
fn bindgen_test_layout_SNodeTypeInfo() {
    assert_eq!(
        ::std::mem::size_of::<SNodeTypeInfo>(),
        48usize,
        concat!("Size of: ", stringify!(SNodeTypeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<SNodeTypeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(SNodeTypeInfo))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SNodeTypeInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SNodeTypeInfo),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_nameOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SNodeTypeInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nameOffset) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SNodeTypeInfo),
                "::",
                stringify!(nameOffset)
            )
        );
    }
    test_field_nameOffset();
    fn test_field_childrenOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SNodeTypeInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).childrenOffset) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SNodeTypeInfo),
                "::",
                stringify!(childrenOffset)
            )
        );
    }
    test_field_childrenOffset();
    fn test_field_arraySize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SNodeTypeInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arraySize) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(SNodeTypeInfo),
                "::",
                stringify!(arraySize)
            )
        );
    }
    test_field_arraySize();
    fn test_field_extra() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SNodeTypeInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extra) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(SNodeTypeInfo),
                "::",
                stringify!(extra)
            )
        );
    }
    test_field_extra();
    fn test_field_extra4() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SNodeTypeInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extra4) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(SNodeTypeInfo),
                "::",
                stringify!(extra4)
            )
        );
    }
    test_field_extra4();
}
#[doc = "information of a Gr2 node"]
pub type TNodeTypeInfo = SNodeTypeInfo;
#[doc = "Mesh transformation (tralsation+rotation+scaling)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct STransformation {
    pub flags: u32,
    pub translation: [f32; 3usize],
    #[doc = " X,Y,Z traslation"]
    pub rotation: [f32; 4usize],
    #[doc = " X,Y,Z,W rotation"]
    pub scaleShear: [[f32; 3usize]; 3usize],
}
#[test]
fn bindgen_test_layout_STransformation() {
    assert_eq!(
        ::std::mem::size_of::<STransformation>(),
        68usize,
        concat!("Size of: ", stringify!(STransformation))
    );
    assert_eq!(
        ::std::mem::align_of::<STransformation>(),
        4usize,
        concat!("Alignment of ", stringify!(STransformation))
    );
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<STransformation>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(STransformation),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_translation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<STransformation>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).translation) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(STransformation),
                "::",
                stringify!(translation)
            )
        );
    }
    test_field_translation();
    fn test_field_rotation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<STransformation>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rotation) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(STransformation),
                "::",
                stringify!(rotation)
            )
        );
    }
    test_field_rotation();
    fn test_field_scaleShear() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<STransformation>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).scaleShear) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(STransformation),
                "::",
                stringify!(scaleShear)
            )
        );
    }
    test_field_scaleShear();
}
#[doc = "Mesh transformation (tralsation+rotation+scaling)"]
pub type TTransformation = STransformation;
